# Жадібні алгоритми та динамічне програмування

Якщо ми оцінюємо коди за їхньою ефективністю в розв'язанні задачі знаходження монет для формування певної суми, то можемо зробити такі висновки:

**Жадібний алгоритм:**

- Використовує простий підхід, що базується на виборі найбільш доступної монети на кожному кроці.
- Має складність O(n), де n - кількість монет, тому працює дуже швидко.
- Зазвичай працює добре для багатьох вхідних даних, але може давати неоптимальний результат для деяких випадків, зокрема, коли монети не мають спільного дільника або величина суми не кратна найбільшій монеті.

**Алгоритм динамічного програмування:**

- Використовує більш складний підхід, що базується на побудові таблиці оптимальних рішень для всіх можливих сум.
- Має складність O(n * m), де n - сума, а m - кількість монет, тому працює трохи повільніше, особливо для великих сум.
- Гарантує оптимальний результат для будь-яких вхідних даних, проте може вимагати більше обчислювальних ресурсів.

Таким чином, обидва підходи мають свої переваги та недоліки, і вибір між ними залежить від конкретних вимог вашого додатка. Якщо вам потрібно швидко отримати результат для невеликих сум, можна використати жадібний алгоритм. У випадку, якщо ви маєте справу з великими сумами або потрібно гарантувати оптимальний результат, краще використовувати динамічне програмування.

Отже, на практиці, обидва підходи можуть бути корисними в залежності від конкретної ситуації, але якщо вам необхідно обрати лише один, і ваша програма працюватиме з великими сумами, то більш ефективним вибором буде алгоритм динамічного програмування.